<html>
  <!--
    This file is a fully-functioning example test case. Try opening this file in Firefox, Safari,
    or Internet Explorer to see what a running test looks like.
    This file demonstrates the the components involved in writing a simple test, such as:
      * The necessary HTML to run a test (with the required <script> and <link rel="stylesheet"> tags),
      * A "custom matcher" (i.e., a custom assertion) to make your tests more readable,
      * And, a simple test with the necessary boiler-plate code to get you up and running.
    Typically, these components are separated out into multiple files. To see what a more typical suite
    of tests look like, look at the larger example in the examples/ directory.
  -->
  <head>
    <!-- These are all of the necessary javascript and css files required to run your tests -->
    <script src="lib/jquery-1.2.3.js"></script>
    <script src="lib/jquery.fn.js"></script>
    <script src="lib/jquery.print.js"></script>
    <script src="lib/screw.builder.js"></script>
    <script src="lib/screw.matchers.js"></script>
    <script src="lib/screw.events.js"></script>
    <script src="lib/screw.behaviors.js"></script>
    <script src="lib/screw.mock.js"></script>
    <link rel="stylesheet" href="lib/screw.css">
    
    <script type="text/javascript">
      // Here is the system under test (SUT)--that is, your application code that you would like
      // to test.
      foo = {
        number: 2
      }
    </script>
    
    <script type="text/javascript">
      // Here is a Custom Matcher. A custom matcher is a custom assertion,
      // tailored to your application; these help to make your tests more readable.
      Screw.Matchers["be_even"] = {
        match: function(expected, actual) {
          return actual % 2 == 0;
        },
        failure_message: function(expected, actual, not) {
          return 'expected ' + $.print(actual) + (not ? ' not' : '') + ' to be even';
        }
      }
    </script>
    
    <script type="text/javascript">
      // Here is a sample test. Note that all tests are wrapped in
      // "Screw.Unit(function() { ... })".
      Screw.Unit(function() {
        // Tests are organized into 'describes' and 'its', following the style of RSpec.
        describe("foo.number", function() {
          // this [before] function is run before every test
          before(function() {
            // restore all objects that were mocked to their original states;
            TH.Mock.reset();
          });
          
          it("returns 2", function() {
            // 'equal' is one among many matchers provided with the Screw.Unit distribution. It
            // is smart enough to compare arrays, objects, and primitives.
            expect(foo.number).to(equal, 2);
          });
          it("is even", function() {
            // Here is a use of the custom matcher defined above.
            expect(foo.number).to(be_even);
          });
          it("is not even when it returns 3", function() {
            // And here is both a mock and the to_not version of the custom matcher
            TH.Mock.obj("foo", { number: 3 });
            expect(foo.number).to_not(be_even);
          });
          
          it("is even in the next test because the mock was restored", function() {
            // since the before function restored the mocked objects, foo has returned to normal
            expect(foo.number).to(be_even);
          });
          
        });
      });
    </script>
  </head>
  <body></body>
</html>